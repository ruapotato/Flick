#!/usr/bin/env python3
"""
Flick Package Manager

Commands:
    list        - List available packages (remote + local)
    installed   - List installed apps
    install     - Install a package
    uninstall   - Remove an installed app
    search      - Search packages
    update      - Update package cache from remote
"""

import os
import sys
import json
import shutil
import argparse
import tempfile
import zipfile
import tarfile
from pathlib import Path
from urllib.request import urlopen, Request
from urllib.error import URLError, HTTPError

# Configuration
DEFAULT_REPO = "https://255.one"
API_BASE = "/api"

def get_home():
    """Get the real user's home directory."""
    for env_var in ['FLICK_USER', 'SUDO_USER']:
        user = os.environ.get(env_var, '')
        if user and user != 'root':
            home = f'/home/{user}'
            if os.path.exists(home):
                return Path(home)
    if os.path.exists('/home/droidian'):
        return Path('/home/droidian')
    return Path(os.environ.get('HOME', '/root'))

HOME = get_home()
FLICK_DIR = HOME / 'Flick'
APPS_DIR = FLICK_DIR / 'apps'
PACKAGES_DIR = FLICK_DIR / 'store' / 'packages'
SIGNAL_FILE = Path('/tmp/flick_rescan_apps')
STATE_DIR = HOME / '.local' / 'state' / 'flick'
CACHE_DIR = STATE_DIR / 'pkg_cache'
INSTALLED_FILE = STATE_DIR / 'store_installed.json'
REPOS_FILE = STATE_DIR / 'repositories.json'

def api_get(endpoint, repo=DEFAULT_REPO):
    """Make a GET request to the API."""
    url = f"{repo}{API_BASE}{endpoint}"
    try:
        req = Request(url, headers={'User-Agent': 'flick-pkg/1.0'})
        with urlopen(req, timeout=30) as response:
            return json.loads(response.read().decode())
    except HTTPError as e:
        print(f"HTTP Error {e.code}: {e.reason}")
        return None
    except URLError as e:
        print(f"Connection error: {e.reason}")
        return None
    except Exception as e:
        print(f"Error: {e}")
        return None

def download_file(url, dest_path):
    """Download a file from URL."""
    try:
        req = Request(url, headers={'User-Agent': 'flick-pkg/1.0'})
        with urlopen(req, timeout=120) as response:
            with open(dest_path, 'wb') as f:
                shutil.copyfileobj(response, f)
        return True
    except Exception as e:
        print(f"Download error: {e}")
        return False

def get_repos():
    """Get list of repositories."""
    if REPOS_FILE.exists():
        try:
            with open(REPOS_FILE) as f:
                data = json.load(f)
                return data.get('repositories', [DEFAULT_REPO])
        except:
            pass
    return [DEFAULT_REPO]

def load_manifest(path):
    """Load a manifest.json file."""
    manifest_path = path / 'manifest.json'
    if manifest_path.exists():
        try:
            with open(manifest_path) as f:
                return json.load(f)
        except:
            pass
    return None

def get_local_app_info(path):
    """Get app info from a local directory."""
    manifest = load_manifest(path)
    app_id = path.name
    if manifest:
        return {
            'id': app_id,
            'name': manifest.get('name', app_id.title()),
            'version': manifest.get('version', '1.0.0'),
            'description': manifest.get('description', ''),
            'source': 'local',
        }
    if (path / 'main.qml').exists() or (path / f'run_{app_id}.sh').exists():
        return {
            'id': app_id,
            'name': app_id.title(),
            'version': '1.0.0',
            'description': '',
            'source': 'local',
        }
    return None

def signal_rescan():
    """Signal the shell to rescan apps."""
    SIGNAL_FILE.touch()
    print("  (Shell will detect new apps automatically)")

def load_store_installed():
    """Load the Store's installed apps list."""
    if INSTALLED_FILE.exists():
        try:
            with open(INSTALLED_FILE) as f:
                return json.load(f).get('apps', [])
        except:
            pass
    return []

def save_store_installed(apps):
    """Save the Store's installed apps list."""
    STATE_DIR.mkdir(parents=True, exist_ok=True)
    with open(INSTALLED_FILE, 'w') as f:
        json.dump({'apps': apps}, f, indent=2)

def add_to_store_installed(info):
    """Add an app to the Store's installed list."""
    import time
    apps = load_store_installed()
    apps = [a for a in apps if a.get('id') != info['id']]
    apps.append({
        'id': info['id'],
        'name': info['name'],
        'icon': info.get('icon', 'app'),
        'version': info['version'],
        'installedAt': int(time.time() * 1000)
    })
    save_store_installed(apps)

def remove_from_store_installed(app_id):
    """Remove an app from the Store's installed list."""
    apps = load_store_installed()
    apps = [a for a in apps if a.get('id') != app_id]
    save_store_installed(apps)

def extract_flick_package(flick_path, dest_dir):
    """Extract a .flick package (zip or tar.gz)."""
    try:
        # Try as zip first
        if zipfile.is_zipfile(flick_path):
            with zipfile.ZipFile(flick_path, 'r') as zf:
                zf.extractall(dest_dir)
            return True
    except:
        pass

    try:
        # Try as tar.gz
        with tarfile.open(flick_path, 'r:*') as tf:
            tf.extractall(dest_dir)
        return True
    except:
        pass

    return False

def cmd_list(args):
    """List available packages from remote and local."""
    print("\nFetching packages from remote repositories...")

    all_packages = []

    # Fetch from remote repos
    for repo in get_repos():
        print(f"  Checking {repo}...")
        data = api_get("/apps?per_page=100", repo)
        if data and 'apps' in data:
            for app in data['apps']:
                all_packages.append({
                    'id': app.get('slug', app.get('id', '')),
                    'name': app.get('name', ''),
                    'version': app.get('version', '1.0.0'),
                    'description': app.get('description', ''),
                    'downloads': app.get('download_count', 0),
                    'source': repo,
                })

    # Add local packages
    if PACKAGES_DIR.exists():
        for pkg_dir in PACKAGES_DIR.iterdir():
            if pkg_dir.is_dir() and not pkg_dir.name.startswith('.'):
                info = get_local_app_info(pkg_dir)
                if info:
                    # Don't duplicate if already in remote
                    if not any(p['id'] == info['id'] for p in all_packages):
                        all_packages.append(info)

    if not all_packages:
        print("\nNo packages available")
        return 0

    print(f"\nAvailable packages ({len(all_packages)}):\n")
    for pkg in sorted(all_packages, key=lambda x: x['name'].lower()):
        installed = (APPS_DIR / pkg['id']).exists()
        status = "[installed]" if installed else ""
        source = "(local)" if pkg.get('source') == 'local' else ""
        print(f"  {pkg['id']:20} {pkg['name'][:25]:25} {status} {source}")
        if pkg.get('description'):
            desc = pkg['description'][:50] + '...' if len(pkg.get('description', '')) > 50 else pkg.get('description', '')
            print(f"                       {desc}")
    print()
    return 0

def cmd_installed(args):
    """List installed apps."""
    skip = {'lockscreen', 'shared', 'welcome', 'store'}
    apps = []

    if APPS_DIR.exists():
        for app_dir in sorted(APPS_DIR.iterdir()):
            if app_dir.is_dir() and not app_dir.name.startswith('.'):
                if app_dir.name in skip:
                    continue
                info = get_local_app_info(app_dir)
                if info:
                    apps.append(info)

    if not apps:
        print("No apps installed")
        return 0

    print(f"\nInstalled apps ({len(apps)}):\n")
    for info in apps:
        print(f"  {info['id']:20} {info['name']:25} v{info['version']}")
    print()
    return 0

def cmd_install(args):
    """Install a package from remote or local."""
    pkg_id = args.package
    dest_dir = APPS_DIR / pkg_id

    if dest_dir.exists():
        print(f"Already installed: {pkg_id}")
        return 1

    # Check local packages first
    local_pkg = PACKAGES_DIR / pkg_id
    if local_pkg.exists():
        info = get_local_app_info(local_pkg)
        if info:
            print(f"Installing {info['name']} ({pkg_id}) from local...")
            try:
                shutil.copytree(local_pkg, dest_dir)
                print(f"  Copied to {dest_dir}")
                add_to_store_installed(info)
                signal_rescan()
                print(f"Successfully installed: {info['name']}")
                return 0
            except Exception as e:
                print(f"Installation failed: {e}")
                return 1

    # Try remote repos
    print(f"Searching remote repositories for {pkg_id}...")
    for repo in get_repos():
        # Get app info
        data = api_get(f"/apps/{pkg_id}", repo)
        if not data or 'app' not in data:
            continue

        app = data['app']
        print(f"Found {app['name']} v{app.get('version', '1.0.0')} on {repo}")

        # Download package
        download_url = f"{repo}{API_BASE}/apps/{pkg_id}/download"
        print(f"  Downloading...")

        CACHE_DIR.mkdir(parents=True, exist_ok=True)
        flick_path = CACHE_DIR / f"{pkg_id}.flick"

        if not download_file(download_url, flick_path):
            print(f"  Failed to download from {repo}")
            continue

        print(f"  Extracting...")

        # Extract to temp dir first
        with tempfile.TemporaryDirectory() as tmpdir:
            tmppath = Path(tmpdir)
            if not extract_flick_package(flick_path, tmppath):
                print(f"  Failed to extract package")
                continue

            # Find the app directory (might be nested)
            app_content = None
            for item in tmppath.iterdir():
                if item.is_dir():
                    if (item / 'main.qml').exists() or (item / 'manifest.json').exists():
                        app_content = item
                        break
            if not app_content:
                # Check if files are at root level
                if (tmppath / 'main.qml').exists() or (tmppath / 'manifest.json').exists():
                    app_content = tmppath

            if not app_content:
                print(f"  Invalid package structure")
                continue

            # Move to apps directory
            shutil.copytree(app_content, dest_dir)

        # Clean up cache
        flick_path.unlink(missing_ok=True)

        info = {
            'id': pkg_id,
            'name': app['name'],
            'version': app.get('version', '1.0.0'),
            'icon': app.get('icon', 'app'),
        }
        add_to_store_installed(info)
        signal_rescan()
        print(f"Successfully installed: {app['name']}")
        return 0

    print(f"Package not found: {pkg_id}")
    return 1

def cmd_uninstall(args):
    """Uninstall an app."""
    app_id = args.package
    app_dir = APPS_DIR / app_id

    protected = {'settings', 'store', 'phone', 'messages', 'contacts', 'browser',
                 'camera', 'gallery', 'files', 'terminal', 'calculator', 'clock',
                 'calendar', 'notes', 'weather', 'maps'}

    if app_id in protected:
        print(f"Cannot uninstall core app: {app_id}")
        return 1

    if not app_dir.exists():
        print(f"App not installed: {app_id}")
        return 1

    info = get_local_app_info(app_dir)
    name = info['name'] if info else app_id

    print(f"Uninstalling {name} ({app_id})...")
    try:
        shutil.rmtree(app_dir)
        print(f"  Removed {app_dir}")
        remove_from_store_installed(app_id)
        signal_rescan()
        print(f"Successfully uninstalled: {name}")
        return 0
    except Exception as e:
        print(f"Uninstall failed: {e}")
        return 1

def cmd_search(args):
    """Search packages."""
    query = args.query.lower()
    results = []

    # Search remote
    for repo in get_repos():
        data = api_get(f"/apps/search?q={query}", repo)
        if data and 'apps' in data:
            for app in data['apps']:
                results.append({
                    'id': app.get('slug', app.get('id', '')),
                    'name': app.get('name', ''),
                    'description': app.get('description', ''),
                    'source': repo,
                })

    # Search local
    if PACKAGES_DIR.exists():
        for pkg_dir in PACKAGES_DIR.iterdir():
            if pkg_dir.is_dir():
                info = get_local_app_info(pkg_dir)
                if info:
                    searchable = f"{info['id']} {info['name']} {info.get('description', '')}".lower()
                    if query in searchable:
                        if not any(r['id'] == info['id'] for r in results):
                            info['source'] = 'local'
                            results.append(info)

    if not results:
        print(f"No packages matching: {query}")
        return 0

    print(f"\nSearch results for '{query}' ({len(results)}):\n")
    for pkg in results:
        installed = (APPS_DIR / pkg['id']).exists()
        status = "[installed]" if installed else ""
        print(f"  {pkg['id']:20} {pkg['name'][:25]:25} {status}")
    print()
    return 0

def cmd_info(args):
    """Show package info."""
    pkg_id = args.package

    # Check installed first
    app_dir = APPS_DIR / pkg_id
    if app_dir.exists():
        info = get_local_app_info(app_dir)
        manifest = load_manifest(app_dir)
        if info:
            print(f"\n{info['name']}")
            print("=" * len(info['name']))
            print(f"ID:          {info['id']}")
            print(f"Version:     {info['version']}")
            print(f"Status:      Installed")
            if manifest and manifest.get('description'):
                print(f"Description: {manifest['description']}")
            print()
            return 0

    # Check remote
    for repo in get_repos():
        data = api_get(f"/apps/{pkg_id}", repo)
        if data and 'app' in data:
            app = data['app']
            print(f"\n{app['name']}")
            print("=" * len(app['name']))
            print(f"ID:          {app.get('slug', pkg_id)}")
            print(f"Version:     {app.get('version', '1.0.0')}")
            print(f"Status:      Not installed")
            print(f"Downloads:   {app.get('download_count', 0)}")
            print(f"Category:    {app.get('category', 'Unknown')}")
            if app.get('description'):
                print(f"Description: {app['description']}")
            print(f"Source:      {repo}")
            print()
            return 0

    # Check local packages
    local_pkg = PACKAGES_DIR / pkg_id
    if local_pkg.exists():
        info = get_local_app_info(local_pkg)
        if info:
            print(f"\n{info['name']}")
            print("=" * len(info['name']))
            print(f"ID:          {info['id']}")
            print(f"Version:     {info['version']}")
            print(f"Status:      Not installed (local package)")
            print()
            return 0

    print(f"Package not found: {pkg_id}")
    return 1

def cmd_update(args):
    """Update package cache from remote."""
    print("Updating package lists...")
    for repo in get_repos():
        print(f"  Fetching from {repo}...")
        data = api_get("/apps?per_page=100", repo)
        if data:
            count = len(data.get('apps', []))
            print(f"    Found {count} packages")
        else:
            print(f"    Failed to connect")
    print("Done.")
    return 0

def main():
    parser = argparse.ArgumentParser(
        description='Flick Package Manager',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=f"""
Default repository: {DEFAULT_REPO}

Examples:
  flick-pkg list              List all available packages
  flick-pkg search game       Search for packages
  flick-pkg install distract  Install a package
  flick-pkg uninstall distract Remove an app
  flick-pkg info distract     Show package details
  flick-pkg update            Refresh package lists
"""
    )

    subparsers = parser.add_subparsers(dest='command', help='Command')

    subparsers.add_parser('list', help='List available packages').set_defaults(func=cmd_list)
    subparsers.add_parser('installed', help='List installed apps').set_defaults(func=cmd_installed)
    subparsers.add_parser('update', help='Update package cache').set_defaults(func=cmd_update)

    p = subparsers.add_parser('install', help='Install a package')
    p.add_argument('package', help='Package ID')
    p.set_defaults(func=cmd_install)

    p = subparsers.add_parser('uninstall', help='Uninstall an app')
    p.add_argument('package', help='App ID')
    p.set_defaults(func=cmd_uninstall)

    p = subparsers.add_parser('search', help='Search packages')
    p.add_argument('query', help='Search query')
    p.set_defaults(func=cmd_search)

    p = subparsers.add_parser('info', help='Show package info')
    p.add_argument('package', help='Package ID')
    p.set_defaults(func=cmd_info)

    args = parser.parse_args()
    if not args.command:
        parser.print_help()
        return 0

    return args.func(args)

if __name__ == '__main__':
    sys.exit(main())
