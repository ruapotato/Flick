//! Simple bitmap text rendering using rectangles
//!
//! Renders text using a simple 5x7 pixel font represented as rectangles.

use super::primitives::{Rect, Color};

/// Width of each character in pixels
const CHAR_WIDTH: f64 = 5.0;
/// Height of each character in pixels
const CHAR_HEIGHT: f64 = 7.0;
/// Space between characters
const CHAR_SPACING: f64 = 1.0;

/// Simple 5x7 bitmap font - each character is a 35-bit pattern
/// Bits are stored row by row, top to bottom, left to right
fn get_char_bitmap(c: char) -> [u8; 7] {
    match c.to_ascii_uppercase() {
        'A' => [0b01110, 0b10001, 0b10001, 0b11111, 0b10001, 0b10001, 0b10001],
        'B' => [0b11110, 0b10001, 0b10001, 0b11110, 0b10001, 0b10001, 0b11110],
        'C' => [0b01110, 0b10001, 0b10000, 0b10000, 0b10000, 0b10001, 0b01110],
        'D' => [0b11110, 0b10001, 0b10001, 0b10001, 0b10001, 0b10001, 0b11110],
        'E' => [0b11111, 0b10000, 0b10000, 0b11110, 0b10000, 0b10000, 0b11111],
        'F' => [0b11111, 0b10000, 0b10000, 0b11110, 0b10000, 0b10000, 0b10000],
        'G' => [0b01110, 0b10001, 0b10000, 0b10111, 0b10001, 0b10001, 0b01110],
        'H' => [0b10001, 0b10001, 0b10001, 0b11111, 0b10001, 0b10001, 0b10001],
        'I' => [0b01110, 0b00100, 0b00100, 0b00100, 0b00100, 0b00100, 0b01110],
        'J' => [0b00111, 0b00010, 0b00010, 0b00010, 0b00010, 0b10010, 0b01100],
        'K' => [0b10001, 0b10010, 0b10100, 0b11000, 0b10100, 0b10010, 0b10001],
        'L' => [0b10000, 0b10000, 0b10000, 0b10000, 0b10000, 0b10000, 0b11111],
        'M' => [0b10001, 0b11011, 0b10101, 0b10101, 0b10001, 0b10001, 0b10001],
        'N' => [0b10001, 0b10001, 0b11001, 0b10101, 0b10011, 0b10001, 0b10001],
        'O' => [0b01110, 0b10001, 0b10001, 0b10001, 0b10001, 0b10001, 0b01110],
        'P' => [0b11110, 0b10001, 0b10001, 0b11110, 0b10000, 0b10000, 0b10000],
        'Q' => [0b01110, 0b10001, 0b10001, 0b10001, 0b10101, 0b10010, 0b01101],
        'R' => [0b11110, 0b10001, 0b10001, 0b11110, 0b10100, 0b10010, 0b10001],
        'S' => [0b01110, 0b10001, 0b10000, 0b01110, 0b00001, 0b10001, 0b01110],
        'T' => [0b11111, 0b00100, 0b00100, 0b00100, 0b00100, 0b00100, 0b00100],
        'U' => [0b10001, 0b10001, 0b10001, 0b10001, 0b10001, 0b10001, 0b01110],
        'V' => [0b10001, 0b10001, 0b10001, 0b10001, 0b10001, 0b01010, 0b00100],
        'W' => [0b10001, 0b10001, 0b10001, 0b10101, 0b10101, 0b11011, 0b10001],
        'X' => [0b10001, 0b10001, 0b01010, 0b00100, 0b01010, 0b10001, 0b10001],
        'Y' => [0b10001, 0b10001, 0b01010, 0b00100, 0b00100, 0b00100, 0b00100],
        'Z' => [0b11111, 0b00001, 0b00010, 0b00100, 0b01000, 0b10000, 0b11111],
        '0' => [0b01110, 0b10001, 0b10011, 0b10101, 0b11001, 0b10001, 0b01110],
        '1' => [0b00100, 0b01100, 0b00100, 0b00100, 0b00100, 0b00100, 0b01110],
        '2' => [0b01110, 0b10001, 0b00001, 0b00010, 0b00100, 0b01000, 0b11111],
        '3' => [0b01110, 0b10001, 0b00001, 0b00110, 0b00001, 0b10001, 0b01110],
        '4' => [0b00010, 0b00110, 0b01010, 0b10010, 0b11111, 0b00010, 0b00010],
        '5' => [0b11111, 0b10000, 0b11110, 0b00001, 0b00001, 0b10001, 0b01110],
        '6' => [0b00110, 0b01000, 0b10000, 0b11110, 0b10001, 0b10001, 0b01110],
        '7' => [0b11111, 0b00001, 0b00010, 0b00100, 0b01000, 0b01000, 0b01000],
        '8' => [0b01110, 0b10001, 0b10001, 0b01110, 0b10001, 0b10001, 0b01110],
        '9' => [0b01110, 0b10001, 0b10001, 0b01111, 0b00001, 0b00010, 0b01100],
        ' ' => [0b00000, 0b00000, 0b00000, 0b00000, 0b00000, 0b00000, 0b00000],
        '-' => [0b00000, 0b00000, 0b00000, 0b11111, 0b00000, 0b00000, 0b00000],
        '.' => [0b00000, 0b00000, 0b00000, 0b00000, 0b00000, 0b01100, 0b01100],
        ':' => [0b00000, 0b01100, 0b01100, 0b00000, 0b01100, 0b01100, 0b00000],
        _ => [0b11111, 0b10001, 0b10001, 0b10001, 0b10001, 0b10001, 0b11111], // Box for unknown
    }
}

/// Get the width of a text string in pixels (at scale 1.0)
pub fn text_width(text: &str) -> f64 {
    if text.is_empty() {
        return 0.0;
    }
    (text.len() as f64) * (CHAR_WIDTH + CHAR_SPACING) - CHAR_SPACING
}

/// Render text as a list of rectangles
/// x, y is the top-left position
/// scale multiplies the base pixel size
/// color is the text color
pub fn render_text(text: &str, x: f64, y: f64, scale: f64, color: Color) -> Vec<(Rect, Color)> {
    let mut rects = Vec::new();
    let pixel_size = scale;

    let mut cursor_x = x;

    for c in text.chars() {
        let bitmap = get_char_bitmap(c);

        for (row, &row_bits) in bitmap.iter().enumerate() {
            for col in 0..5 {
                // Check if this pixel is set (bit 4-col because we store left-to-right)
                if (row_bits >> (4 - col)) & 1 == 1 {
                    let px = cursor_x + (col as f64) * pixel_size;
                    let py = y + (row as f64) * pixel_size;
                    rects.push((Rect::new(px, py, pixel_size, pixel_size), color));
                }
            }
        }

        cursor_x += (CHAR_WIDTH + CHAR_SPACING) * scale;
    }

    rects
}

/// Render text centered horizontally within a given width
pub fn render_text_centered(text: &str, center_x: f64, y: f64, scale: f64, color: Color) -> Vec<(Rect, Color)> {
    let width = text_width(text) * scale;
    let x = center_x - width / 2.0;
    render_text(text, x, y, scale, color)
}
