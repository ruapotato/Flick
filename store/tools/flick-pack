#!/usr/bin/env python3
"""
Flick Package Tool - Create, install, and manage .flick packages

SPDX-License-Identifier: AGPL-3.0-or-later
Copyright (C) 2026 Flick Project
"""

import argparse
import json
import os
import shutil
import subprocess
import sys
import tempfile
import zipfile
from datetime import datetime
from pathlib import Path

VERSION = "1.0.0"

# Default paths
FLICK_APPS_DIR = Path.home() / ".local/share/flick/apps"
FLICK_STATE_DIR = Path.home() / ".local/state/flick"
FLICK_DESKTOP_DIR = Path.home() / ".local/share/applications"

# Required manifest fields
REQUIRED_FIELDS = ["format_version", "id", "name", "version", "description", "author", "license", "app"]


def log(msg, level="info"):
    """Print colored log message."""
    colors = {
        "info": "\033[36m",    # Cyan
        "success": "\033[32m",  # Green
        "warning": "\033[33m",  # Yellow
        "error": "\033[31m",    # Red
    }
    reset = "\033[0m"
    prefix = {"info": "[*]", "success": "[+]", "warning": "[!]", "error": "[-]"}
    print(f"{colors.get(level, '')}{prefix.get(level, '[*]')} {msg}{reset}")


def validate_manifest(manifest):
    """Validate manifest.json structure."""
    errors = []

    for field in REQUIRED_FIELDS:
        if field not in manifest:
            errors.append(f"Missing required field: {field}")

    if "app" in manifest:
        app = manifest["app"]
        if "type" not in app:
            errors.append("Missing app.type")
        if "entry" not in app and app.get("type") != "hybrid":
            errors.append("Missing app.entry")

    if "author" in manifest:
        if "name" not in manifest["author"]:
            errors.append("Missing author.name")

    # Validate version format
    if "version" in manifest:
        parts = manifest["version"].split(".")
        if len(parts) != 3:
            errors.append("Version must be in format X.Y.Z")

    return errors


def create_package(source_dir, output_path=None, verbose=False):
    """Create a .flick package from a directory."""
    source = Path(source_dir).resolve()

    if not source.exists():
        log(f"Source directory not found: {source}", "error")
        return False

    # Check for manifest
    manifest_path = source / "manifest.json"
    if not manifest_path.exists():
        log("manifest.json not found in source directory", "error")
        return False

    # Load and validate manifest
    try:
        with open(manifest_path) as f:
            manifest = json.load(f)
    except json.JSONDecodeError as e:
        log(f"Invalid manifest.json: {e}", "error")
        return False

    errors = validate_manifest(manifest)
    if errors:
        log("Manifest validation failed:", "error")
        for err in errors:
            log(f"  - {err}", "error")
        return False

    # Check for required files based on app type
    app_type = manifest["app"]["type"]

    if app_type == "qml":
        app_dir = source / "app"
        if not app_dir.exists():
            log("app/ directory not found (required for QML apps)", "error")
            return False
        entry_file = app_dir / manifest["app"].get("entry", "main.qml")
        if not entry_file.exists():
            log(f"Entry file not found: {entry_file}", "error")
            return False
    elif app_type == "rust":
        build_dir = source / "build"
        if not build_dir.exists():
            log("build/ directory not found (required for Rust apps)", "error")
            return False
        cargo_file = build_dir / "Cargo.toml"
        if not cargo_file.exists():
            log("build/Cargo.toml not found", "error")
            return False
    elif app_type == "hybrid":
        # Hybrid apps need both
        app_dir = source / "app"
        build_dir = source / "build"
        if not app_dir.exists():
            log("app/ directory not found (required for hybrid apps)", "error")
            return False
        if not build_dir.exists():
            log("build/ directory not found (required for hybrid apps)", "error")
            return False

    icon_path = source / "icon.png"
    if not icon_path.exists():
        log("icon.png not found (required)", "warning")

    # Determine output path
    if not output_path:
        output_path = source.parent / f"{manifest['id']}-{manifest['version']}.flick"
    else:
        output_path = Path(output_path)

    log(f"Creating package: {output_path}")

    # Create ZIP archive
    with zipfile.ZipFile(output_path, 'w', zipfile.ZIP_DEFLATED) as zf:
        for root, dirs, files in os.walk(source):
            # Skip hidden files and directories
            dirs[:] = [d for d in dirs if not d.startswith('.')]

            for file in files:
                if file.startswith('.'):
                    continue

                file_path = Path(root) / file
                arcname = file_path.relative_to(source)

                if verbose:
                    log(f"  Adding: {arcname}")

                zf.write(file_path, arcname)

    # Get file size
    size = output_path.stat().st_size
    size_str = f"{size / 1024:.1f} KB" if size < 1024 * 1024 else f"{size / 1024 / 1024:.1f} MB"

    log(f"Package created: {output_path} ({size_str})", "success")
    return True


def extract_package(package_path, output_dir=None, verbose=False):
    """Extract a .flick package."""
    package = Path(package_path).resolve()

    if not package.exists():
        log(f"Package not found: {package}", "error")
        return None

    if not output_dir:
        output_dir = Path(tempfile.mkdtemp(prefix="flick_"))
    else:
        output_dir = Path(output_dir)
        output_dir.mkdir(parents=True, exist_ok=True)

    log(f"Extracting to: {output_dir}")

    with zipfile.ZipFile(package, 'r') as zf:
        zf.extractall(output_dir)

    return output_dir


def install_package(package_path, force=False, verbose=False):
    """Install a .flick package."""
    package = Path(package_path).resolve()

    if not package.exists():
        log(f"Package not found: {package}", "error")
        return False

    # Extract to temp directory
    temp_dir = extract_package(package, verbose=verbose)
    if not temp_dir:
        return False

    try:
        # Load manifest
        manifest_path = temp_dir / "manifest.json"
        with open(manifest_path) as f:
            manifest = json.load(f)

        app_id = manifest["id"]
        app_name = manifest["name"]
        app_version = manifest["version"]

        log(f"Installing {app_name} v{app_version} ({app_id})")

        # Check if already installed
        install_dir = FLICK_APPS_DIR / app_id
        if install_dir.exists():
            if not force:
                log(f"App already installed. Use --force to reinstall.", "warning")
                return False
            log("Removing existing installation...")
            shutil.rmtree(install_dir)

        # Install dependencies
        deps = manifest.get("dependencies", {})

        # APT dependencies
        apt_deps = deps.get("apt", [])
        if apt_deps:
            log(f"Installing APT dependencies: {', '.join(apt_deps)}")
            try:
                subprocess.run(
                    ["sudo", "apt-get", "install", "-y"] + apt_deps,
                    check=True,
                    capture_output=not verbose
                )
                log("APT dependencies installed", "success")
            except subprocess.CalledProcessError:
                log("Failed to install APT dependencies", "error")
                return False

        # Pip dependencies
        pip_config = deps.get("pip", {})
        if pip_config.get("enabled") and pip_config.get("packages"):
            log("Setting up Python virtual environment...")
            venv_dir = install_dir / ".venv"

            try:
                subprocess.run(
                    [sys.executable, "-m", "venv", str(venv_dir)],
                    check=True,
                    capture_output=not verbose
                )

                pip_path = venv_dir / "bin" / "pip"
                packages = pip_config["packages"]

                log(f"Installing pip packages: {', '.join(packages)}")
                subprocess.run(
                    [str(pip_path), "install"] + packages,
                    check=True,
                    capture_output=not verbose
                )
                log("Pip dependencies installed", "success")
            except subprocess.CalledProcessError:
                log("Failed to install pip dependencies", "error")
                return False

        # Copy app files
        log("Copying app files...")
        FLICK_APPS_DIR.mkdir(parents=True, exist_ok=True)
        shutil.copytree(temp_dir, install_dir)

        # Handle build if needed
        build_config = manifest.get("build", {})
        if build_config.get("type") == "cargo":
            log("Building Rust application...")
            build_dir = install_dir / "build"
            if build_dir.exists():
                try:
                    subprocess.run(
                        ["cargo", "build", "--release"],
                        cwd=build_dir,
                        check=True,
                        capture_output=not verbose
                    )
                    log("Build complete", "success")
                except subprocess.CalledProcessError:
                    log("Build failed", "error")
                    return False

        # Create .desktop file
        create_desktop_file(manifest, install_dir)

        # Register with Flick shell
        register_app(manifest, install_dir)

        log(f"{app_name} installed successfully!", "success")
        return True

    finally:
        # Cleanup temp directory
        shutil.rmtree(temp_dir, ignore_errors=True)


def create_desktop_file(manifest, install_dir):
    """Create a .desktop file for the app."""
    app_id = manifest["id"]
    app_name = manifest["name"]
    app_type = manifest["app"]["type"]
    entry = manifest["app"].get("entry", "main.qml")
    comment = manifest.get("description", "")
    categories = ";".join(manifest.get("categories", ["Utility"])) + ";"

    # Determine exec command
    if app_type == "qml":
        exec_cmd = f"qmlscene {install_dir}/app/{entry}"
    elif app_type == "rust":
        exec_cmd = f"{install_dir}/build/target/release/{entry}"
    else:
        exec_cmd = f"qmlscene {install_dir}/app/{manifest['app'].get('qml_entry', 'main.qml')}"

    # Icon path
    icon_path = install_dir / "icon.png"
    icon = str(icon_path) if icon_path.exists() else "application-x-executable"

    desktop_content = f"""[Desktop Entry]
Type=Application
Name={app_name}
Comment={comment}
Exec={exec_cmd}
Icon={icon}
Terminal=false
Categories={categories}
X-Flick-App-ID={app_id}
X-Flick-Version={manifest['version']}
"""

    FLICK_DESKTOP_DIR.mkdir(parents=True, exist_ok=True)
    desktop_file = FLICK_DESKTOP_DIR / f"flick-{app_id}.desktop"

    with open(desktop_file, 'w') as f:
        f.write(desktop_content)

    os.chmod(desktop_file, 0o755)
    log(f"Created desktop file: {desktop_file}")


def register_app(manifest, install_dir):
    """Register app with Flick shell."""
    FLICK_STATE_DIR.mkdir(parents=True, exist_ok=True)

    registry_file = FLICK_STATE_DIR / "installed_apps.json"

    # Load existing registry
    if registry_file.exists():
        with open(registry_file) as f:
            registry = json.load(f)
    else:
        registry = {"apps": {}}

    # Add app entry
    registry["apps"][manifest["id"]] = {
        "name": manifest["name"],
        "version": manifest["version"],
        "install_path": str(install_dir),
        "installed_at": datetime.now().isoformat(),
        "ai_generated": manifest.get("ai_generated", {}).get("is_ai_generated", False)
    }

    # Save registry
    with open(registry_file, 'w') as f:
        json.dump(registry, f, indent=2)

    log("Registered with Flick shell")


def uninstall_package(app_id, verbose=False):
    """Uninstall an app by ID."""
    install_dir = FLICK_APPS_DIR / app_id

    if not install_dir.exists():
        log(f"App not found: {app_id}", "error")
        return False

    # Load manifest for app name
    manifest_path = install_dir / "manifest.json"
    if manifest_path.exists():
        with open(manifest_path) as f:
            manifest = json.load(f)
        app_name = manifest.get("name", app_id)
    else:
        app_name = app_id

    log(f"Uninstalling {app_name}...")

    # Remove app directory
    shutil.rmtree(install_dir)
    log("Removed app files")

    # Remove desktop file
    desktop_file = FLICK_DESKTOP_DIR / f"flick-{app_id}.desktop"
    if desktop_file.exists():
        desktop_file.unlink()
        log("Removed desktop file")

    # Update registry
    registry_file = FLICK_STATE_DIR / "installed_apps.json"
    if registry_file.exists():
        with open(registry_file) as f:
            registry = json.load(f)

        if app_id in registry.get("apps", {}):
            del registry["apps"][app_id]

            with open(registry_file, 'w') as f:
                json.dump(registry, f, indent=2)
            log("Updated registry")

    log(f"{app_name} uninstalled successfully!", "success")
    return True


def list_installed(verbose=False):
    """List installed apps."""
    registry_file = FLICK_STATE_DIR / "installed_apps.json"

    if not registry_file.exists():
        log("No apps installed")
        return

    with open(registry_file) as f:
        registry = json.load(f)

    apps = registry.get("apps", {})

    if not apps:
        log("No apps installed")
        return

    print("\nInstalled Flick Apps:")
    print("-" * 60)

    for app_id, info in apps.items():
        ai_badge = " [AI]" if info.get("ai_generated") else ""
        print(f"  {info['name']}{ai_badge}")
        print(f"    ID: {app_id}")
        print(f"    Version: {info['version']}")
        if verbose:
            print(f"    Path: {info['install_path']}")
            print(f"    Installed: {info['installed_at']}")
        print()


def info_package(package_path):
    """Show information about a .flick package."""
    package = Path(package_path).resolve()

    if not package.exists():
        log(f"Package not found: {package}", "error")
        return

    with zipfile.ZipFile(package, 'r') as zf:
        try:
            manifest_data = zf.read("manifest.json")
            manifest = json.loads(manifest_data)
        except (KeyError, json.JSONDecodeError):
            log("Invalid package: cannot read manifest", "error")
            return

    print(f"\n{'=' * 60}")
    print(f"Package: {package.name}")
    print(f"{'=' * 60}")
    print(f"Name:        {manifest.get('name', 'Unknown')}")
    print(f"ID:          {manifest.get('id', 'Unknown')}")
    print(f"Version:     {manifest.get('version', 'Unknown')}")
    print(f"License:     {manifest.get('license', 'Unknown')}")
    print(f"Author:      {manifest.get('author', {}).get('name', 'Unknown')}")
    print(f"Type:        {manifest.get('app', {}).get('type', 'Unknown')}")
    print()
    print(f"Description:")
    print(f"  {manifest.get('description', 'No description')}")
    print()

    # Dependencies
    deps = manifest.get("dependencies", {})
    apt_deps = deps.get("apt", [])
    pip_config = deps.get("pip", {})

    if apt_deps or pip_config.get("packages"):
        print("Dependencies:")
        if apt_deps:
            print(f"  APT: {', '.join(apt_deps)}")
        if pip_config.get("packages"):
            print(f"  Pip: {', '.join(pip_config['packages'])}")
        print()

    # AI info
    ai_info = manifest.get("ai_generated", {})
    if ai_info.get("is_ai_generated"):
        print("AI Generated: Yes")
        print(f"  Generator: {ai_info.get('generator_version', 'Unknown')}")
        print(f"  Date: {ai_info.get('generation_date', 'Unknown')}")
        print()

    # Permissions
    perms = manifest.get("permissions", [])
    if perms:
        print(f"Permissions: {', '.join(perms)}")
        print()


def init_app(directory, name=None, app_type="qml"):
    """Initialize a new Flick app project."""
    path = Path(directory).resolve()

    if path.exists() and any(path.iterdir()):
        log("Directory is not empty", "error")
        return False

    path.mkdir(parents=True, exist_ok=True)

    # Generate app ID from name or directory
    if not name:
        name = path.name.replace("-", " ").replace("_", " ").title()

    app_id = f"com.flick.{path.name.lower().replace('-', '').replace('_', '')}"

    log(f"Initializing new Flick app: {name}")

    # Create manifest
    manifest = {
        "format_version": 1,
        "id": app_id,
        "name": name,
        "version": "1.0.0",
        "description": f"{name} - A Flick app",
        "long_description": "",
        "author": {
            "name": os.environ.get("USER", "Developer"),
            "email": "",
            "url": ""
        },
        "license": "AGPL-3.0",
        "categories": ["Utility"],
        "keywords": [],
        "app": {
            "type": app_type,
            "entry": "main.qml" if app_type == "qml" else path.name,
            "min_flick_version": "1.0.0"
        },
        "dependencies": {
            "apt": [],
            "pip": {
                "enabled": False,
                "packages": [],
                "python_version": "3.11"
            }
        },
        "permissions": [],
        "ai_generated": {
            "is_ai_generated": False
        },
        "store": {
            "maturity_rating": "everyone",
            "price": "free",
            "testing_status": "development"
        }
    }

    with open(path / "manifest.json", 'w') as f:
        json.dump(manifest, f, indent=2)

    # Create app directory
    app_dir = path / "app"
    app_dir.mkdir()

    if app_type == "qml":
        # Create main.qml template
        main_qml = '''import QtQuick 2.15
import QtQuick.Window 2.15
import QtQuick.Controls 2.15

Window {
    id: root
    visible: true
    visibility: Window.FullScreen
    width: 1080
    height: 2400
    title: "%s"
    color: "#0a0a0f"

    property real textScale: 1.0
    property color accentColor: "#e94560"

    Component.onCompleted: {
        loadConfig()
    }

    function loadConfig() {
        var xhr = new XMLHttpRequest()
        xhr.open("GET", "file:///home/droidian/.local/state/flick/display_config.json", false)
        try {
            xhr.send()
            if (xhr.status === 200 || xhr.status === 0) {
                var config = JSON.parse(xhr.responseText)
                textScale = config.text_scale || 1.0
            }
        } catch (e) {}
    }

    // Header
    Rectangle {
        id: header
        anchors.top: parent.top
        anchors.left: parent.left
        anchors.right: parent.right
        height: 180
        color: "transparent"

        Column {
            anchors.centerIn: parent
            spacing: 12

            Text {
                anchors.horizontalCenter: parent.horizontalCenter
                text: "%s"
                font.pixelSize: 48 * textScale
                font.weight: Font.ExtraLight
                font.letterSpacing: 6
                color: "#ffffff"
            }

            Text {
                anchors.horizontalCenter: parent.horizontalCenter
                text: "YOUR APP"
                font.pixelSize: 14 * textScale
                font.weight: Font.Medium
                font.letterSpacing: 4
                color: "#555566"
            }
        }
    }

    // Main content area
    Item {
        anchors.top: header.bottom
        anchors.left: parent.left
        anchors.right: parent.right
        anchors.bottom: parent.bottom
        anchors.margins: 16
        anchors.bottomMargin: 100

        Text {
            anchors.centerIn: parent
            text: "Hello, Flick!"
            font.pixelSize: 32 * textScale
            color: "#ffffff"
        }
    }

    // Back button
    Rectangle {
        anchors.right: parent.right
        anchors.bottom: parent.bottom
        anchors.rightMargin: 24
        anchors.bottomMargin: 120
        width: 72
        height: 72
        radius: 36
        color: backMouse.pressed ? Qt.darker(accentColor, 1.2) : accentColor

        Behavior on color { ColorAnimation { duration: 150 } }

        Text {
            anchors.centerIn: parent
            text: "â†"
            font.pixelSize: 32
            font.weight: Font.Medium
            color: "#ffffff"
        }

        MouseArea {
            id: backMouse
            anchors.fill: parent
            onClicked: Qt.quit()
        }
    }

    // Home indicator
    Rectangle {
        anchors.horizontalCenter: parent.horizontalCenter
        anchors.bottom: parent.bottom
        anchors.bottomMargin: 8
        width: 120
        height: 4
        radius: 2
        color: "#333344"
    }
}
''' % (name, name)

        with open(app_dir / "main.qml", 'w') as f:
            f.write(main_qml)

    # Create placeholder icon
    log("Note: Add icon.png (256x256) to complete the package")

    # Create screenshots directory
    (path / "screenshots").mkdir()

    log(f"Project initialized at: {path}", "success")
    log("Next steps:")
    log("  1. Edit app/main.qml")
    log("  2. Add icon.png (256x256)")
    log("  3. Update manifest.json")
    log(f"  4. Run: flick-pack pack {path}")

    return True


def main():
    parser = argparse.ArgumentParser(
        description="Flick Package Tool - Create and manage .flick packages",
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    parser.add_argument("--version", action="version", version=f"flick-pack {VERSION}")

    subparsers = parser.add_subparsers(dest="command", help="Commands")

    # pack command
    pack_parser = subparsers.add_parser("pack", help="Create a .flick package")
    pack_parser.add_argument("source", help="Source directory")
    pack_parser.add_argument("-o", "--output", help="Output file path")
    pack_parser.add_argument("-v", "--verbose", action="store_true")

    # install command
    install_parser = subparsers.add_parser("install", help="Install a .flick package")
    install_parser.add_argument("package", help="Package file (.flick)")
    install_parser.add_argument("-f", "--force", action="store_true", help="Force reinstall")
    install_parser.add_argument("-v", "--verbose", action="store_true")

    # uninstall command
    uninstall_parser = subparsers.add_parser("uninstall", help="Uninstall an app")
    uninstall_parser.add_argument("app_id", help="App ID to uninstall")
    uninstall_parser.add_argument("-v", "--verbose", action="store_true")

    # list command
    list_parser = subparsers.add_parser("list", help="List installed apps")
    list_parser.add_argument("-v", "--verbose", action="store_true")

    # info command
    info_parser = subparsers.add_parser("info", help="Show package information")
    info_parser.add_argument("package", help="Package file (.flick)")

    # init command
    init_parser = subparsers.add_parser("init", help="Initialize a new Flick app")
    init_parser.add_argument("directory", help="Directory for new app")
    init_parser.add_argument("-n", "--name", help="App name")
    init_parser.add_argument("-t", "--type", choices=["qml", "rust", "hybrid"], default="qml")

    # extract command
    extract_parser = subparsers.add_parser("extract", help="Extract a .flick package")
    extract_parser.add_argument("package", help="Package file (.flick)")
    extract_parser.add_argument("-o", "--output", help="Output directory")
    extract_parser.add_argument("-v", "--verbose", action="store_true")

    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        return

    if args.command == "pack":
        success = create_package(args.source, args.output, args.verbose)
        sys.exit(0 if success else 1)

    elif args.command == "install":
        success = install_package(args.package, args.force, args.verbose)
        sys.exit(0 if success else 1)

    elif args.command == "uninstall":
        success = uninstall_package(args.app_id, args.verbose)
        sys.exit(0 if success else 1)

    elif args.command == "list":
        list_installed(args.verbose)

    elif args.command == "info":
        info_package(args.package)

    elif args.command == "init":
        success = init_app(args.directory, args.name, args.type)
        sys.exit(0 if success else 1)

    elif args.command == "extract":
        result = extract_package(args.package, args.output, args.verbose)
        if result:
            log(f"Extracted to: {result}", "success")
        else:
            sys.exit(1)


if __name__ == "__main__":
    main()
